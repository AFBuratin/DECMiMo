\documentclass{article}
\usepackage[margin=2cm]{geometry}
\title{Sensitivity and precision using the ALZ dataset}
\author{Alessia Buratin}
\begin{document}
%\SweaveOpts{concordance=TRUE}
\maketitle

\section{Load the benchmarking results}

We load the benchmarking results, which were produced by the script 
\texttt{glm\_glmm\_paired.R}.

<<loadData>>=
basedir = "/blackhole/alessia/GLMM_article/"
Dataset = c("ALZ","IPF")

load(file = "/blackhole/alessia/GLMM_article/robustness/robustness_30rep_GLM_GLMM.RData")
load(file = "/blackhole/alessia/GLMM_article/robustness/robustnessIPF_30rep_GLM_GLMM.RData")

@ 

The evaluation set results are contained in the \texttt{resTes} object 
and the verification set results are contained in the \texttt{resHeldout} object,
each a list, one element for each random replicate, of data frames which contain
a column for each algorithm giving the adjusted $p$-values for each circRNA. 
For $p$-value adjustment, the \textit{p.adjust} function was used with 
\texttt{method="BH"} (Benjamini-Hochberg correction), 
over only those genes with non-zero row sum.

<<functions>>=
library("ggplot2")
library("reshape")
library("data.table")
library("dplyr")
alpha=.1
getCalls <- function(m, alpha=NULL) {
  t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sum(m[[i]][[algo]][!is.na(m[[i]][[algo]])]<0.1)
    # sum((m[[i]][[algo]] < alpha))
  })))
}

getSensitivityAlgo <- function(m, alpha, alphaOut) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigHeldout <- resHeldout[[m]][[i]][[algo]] <= alpha
    mean((resTes[[m]][[i]][[algo]] <= alpha)[sigHeldout])
  })))
}

getPrecisionAlgo <- function(m, alpha, alphaOut) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigTest <- resTes[[m]][[i]][[algo]] <= alpha #Evaluation set
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout[[m]][[i]][[algo]] <= alpha)[sigTest]) #TP rate
  })))
}

getSensitivityAlgoGold <- function(m, alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigHeldout <- resHeldoutALL[[m]][[i]][[gold]] < alphaOut
    mean((resTestALL[[m]][[i]][[algo]] < alpha)[!is.na(sigHeldout)])
  })))
}

getPrecisionAlgoGold <- function(m, alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigTest <- resTestALL[[m]][[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldoutALL[[m]][[i]][[gold]] < alphaOut)[!is.na(sigTest)])
  })))
}
@ 

The following function helps to rename algorithms. 

<<renameAtoB>>=
renameAtoB <- function(f,a,b) {
  levels(f)[levels(f) == a] <- b
  f
}
@ 

<<namesAlgos>>=
namesAlgos <- c("DESeq2",
                "edgeR-robust",
                "voom",
                "GLMM")
names(namesAlgos) <- namesAlgos
@ 

<<colorAlgorithm>>=
library(RColorBrewer)
cols <- c(
  # GLMM
  brewer.pal(n = 9, "BuPu")[c(5)],
  
  # DEseq
  brewer.pal(n = 9, "YlOrRd")[c(3)],
  # Edger
  brewer.pal(n = 9, name = "GnBu")[c(5)],
  # limma
  brewer.pal(n = 9, "RdPu")[c(5)]
)

methods2 <- c("GLMM",
              
              "DESeq2",
             
              "edgeR-robust",
              
              "voom")
names(cols) <- methods2

@

\clearpage

\section{Counting number of calls}

Here we produce boxplots of the number of calls based on adjusted $p$-value
for each algorithm in the evaluation set and verification set for each random replicate.

<<countCalls>>=
nreps <- 30
nalgo <- 4
# nmethods <- length(names(resHeldout))

resTes.adj = lapply(res_GLM_GLMM_rep_Test, function(x){
  new.res = x %>% dplyr::select(-GLMM)
  new.res = new.res %>% dplyr::rename(GLMM = GLMMadj)
  return(new.res)})

resHeldout.adj = lapply(res_GLM_GLMM_rep_Heldout, function(x){
  new.res = x %>% dplyr::select(-GLMM)
  new.res = new.res %>% dplyr::rename(GLMM = GLMMadj)
  return(new.res)})

# resTes.adj_20 = resTes.adj
# resTest_tall = append(resTes.adj, resTes.adj_20)
# names(resTest_tall) = seq(1,30, by=1)
# resHeldout.adj_20 = resHeldout.adj
# resHeldout_tall = append(resHeldout.adj, resHeldout.adj_20)
# names(resHeldout_tall) = seq(1,30, by=1)
# save(resTest_tall, resHeldout_tall, "/blackhole/alessia/CircModel/robustness/TALL_padj_30rep.RData")
# load("/blackhole/alessia/CircModel/robustness/TALL_padj_30rep.RData")
heldMat <- getCalls(m = resHeldout.adj, alpha = .1)
testMat <- getCalls(m = resTes.adj, alpha = .1)

d <- data.frame(heldoutCalls=reshape2::melt(heldMat)$value,
                testCalls=reshape2::melt(testMat)$value,
                algorithm=factor(rep(namesAlgos,each=nrow(heldMat)),
                levels=namesAlgos))
                #detection.method=rep(factor(rep(names(resHeldout), each=nrow(heldMat))), nalgo))
d$algorithm <- renameAtoB(d$algorithm, "edgeR.robust", "edgeR-robust")

d$algorithm <- as.character(d$algorithm)

d <- d %>%
  mutate_if(sapply(d, is.character), as.factor)
d$heldoutCalls <- as.numeric(d$heldoutCalls)
d$testCalls <- as.numeric(d$testCalls)
@

<<testCalls, dev="pdf", fig.align="center", fig.width=8, fig.height=6, fig.cap="Evaluation set calls (adjusted $p$-value $< .1$)">>=
p <- ggplot(d, aes(x=reorder(algorithm,testCalls,median),y=testCalls,color=algorithm))
png(paste0("/blackhole/alessia/GLMM_article/consinstency/DEcalls_evaluation_", Dataset[2],".png"), res = 150, units = "cm", width = 15, height = 15)
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() +
    geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
    # facet_grid(.~detection.method) +
    scale_color_manual(values = cols, guide="none") +
  theme(plot.margin = unit(c(0,0,0,0), "cm"),
          legend.position = "none",
          panel.spacing = unit(1,"lines"),
          axis.text.x = element_text(angle = 30, hjust = 1, size = 14,face="bold"),
          axis.text.y = element_text(size = 14),
          title = element_text(size = 15),
          axis.title=element_text(size=14,face="bold"),
          strip.text.x = element_text(size = 14)) +
  xlab("") + 
    ggtitle(paste0(Dataset, " - Dataset")) +
    ylab("number of DE calls in Evaluation set")
dev.off()
@ 

<<heldoutCalls, dev="pdf", fig.align="center", fig.width=8, fig.height=6, fig.cap="Verification set calls (adjusted $p$-value $< .1$)">>=
p <- ggplot(d, aes(x=reorder(algorithm,heldoutCalls,median),y=heldoutCalls,color=algorithm))
png(paste0("/blackhole/alessia/GLMM_article/consinstency/DEcalls_verification_", Dataset[2],".png"), res = 150, units = "cm", width = 15, height = 15)
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() +
    geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
    # facet_grid(.~detection.method) +
    scale_color_manual(values = cols, guide="none") +
    theme(plot.margin = unit(c(0,0,0,0), "cm"),
          legend.position = "none",
          panel.spacing = unit(1,"lines"),
          axis.text.x = element_text(angle = 30, hjust = 1, size = 14,face="bold"),
          axis.text.y = element_text(size = 14),
          title = element_text(size = 15),
          axis.title=element_text(size=14,face="bold"),
          strip.text.x = element_text(size = 14)) +
  xlab("") + 
    ggtitle(paste0(Dataset, " - Dataset")) +
    ylab("number of DE calls in Verification set")
dev.off()
@ 

\clearpage

\section{Sensitivity and precision plots}

We construct a data frame containing the sensitivity and
precision estimates for every algorithm in the 
evaluation set and the verification set.

<<constructGrid>>=
nreps = 30
gold = "GLMM"
alpha = .1 
alphaOut = .1
resHeldout = lapply(resHeldout.adj, function(x){z=x[complete.cases(x),]
return(z)})
resTes = lapply(resTes.adj, function(x){z=x[complete.cases(x),]
return(z)})

getSensitivityAlgoGold <- function(alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigHeldout <- resHeldout.adj[[i]][[gold]] <= alphaOut
    mean((resTes.adj[[i]][[algo]] <= alpha)[sigHeldout])
  })))
}
sensMat <- do.call(rbind,lapply(namesAlgos, function(algo) {
    res <- getSensitivityAlgoGold(.1,.1,algo)
    data.frame(res,heldout=rep(algo,nrow(res)))
}))
colnames(sensMat) = c("DESeq2","edgeR-robust","voom","GLMM","heldout")
sensMelt <- melt(sensMat, id="heldout")
names(sensMelt) <- c("heldout","test","sensitivity")
names(sensMelt) <- c("verification","evaluation","sensitivity")
sensMelt = sensMelt %>% dplyr::filter(verification==evaluation)


getPrecisionAlgoGold <- function(alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigTest <- resTes.adj[[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout.adj[[i]][[gold]] < alphaOut)[sigTest])
  })))
}
precMat <- do.call(rbind,lapply(namesAlgos, function(algo) {
    res <- getPrecisionAlgoGold(.1,.1,algo)
    data.frame(res,heldout=rep(algo,nrow(res)))
}))
colnames(precMat) = c("DESeq2","edgeR-robust","voom","GLMM","heldout")
precMelt <- melt(precMat, id="heldout")
names(precMelt) <- c("heldout","test","precision")
names(precMelt) <- c("verification","evaluation","precision")
precMelt = precMelt %>% dplyr::filter(verification==evaluation)

d <- data.frame(sensMelt, precision=precMelt$precision)
d$evaluation <- factor(d$evaluation, levels=namesAlgos)
d$verification <- factor(d$verification, levels=namesAlgos)

## single gold
res = t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigHeldout <- resHeldout.adj[[i]][[gold]] < alphaOut
    mean((resTes.adj[[i]][[algo]] < alpha)[sigHeldout])
  })))
sensMat  = data.frame(res, heldout=rep("GLMM",nrow(res)))
colnames(sensMat) = c("DESeq2","edgeR-robust","voom","GLMM","heldout")
sensMelt <- suppressWarnings(melt(sensMat, id=c("heldout")))
names(sensMelt) <- c("verification", "evaluation","sensitivity")

res = t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigTest <- resTes.adj[[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout.adj[[i]][[gold]] < alphaOut)[sigTest])
  })))
precMat = data.frame(res, heldout=rep("GLMM", nrow(res)))
colnames(precMat) = c("DESeq2","edgeR-robust","voom","GLMM","heldout")
precMelt <- suppressWarnings(melt(precMat, id=c("heldout")))
names(precMelt) <- c("verification", "evaluation","precision")

d <- data.frame(sensMelt, precision=precMelt$precision)
d$evaluation <- factor(d$evaluation)
d$verification <- factor(d$verification)
@ 

<<renameSensResults>>=
d$evaluation <- renameAtoB(d$evaluation, "edgeR.robust", "edgeR-robust")
d$verification <- renameAtoB(d$verification, "edgeR.robust", "edgeR-robust")
d <- d %>%
  mutate_if(sapply(d, is.character), as.factor)
# d$verification <- renameAtoB(d$verification, "GLMM", "GLMM-ZINB")
# d$evaluation <- renameAtoB(d$evaluation, "GLMM", "GLMM-ZINB")
png(paste0("/blackhole/alessia/GLMM_article/robustness/Power_sensitivity_gold", Dataset[2],"_adj.png"), res = 150, units = "cm", width = 18, height = 18)
p <- ggplot(d, aes(x=evaluation,y=sqrt(sensitivity),color=evaluation))
p + scale_color_manual(values = cols) + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + facet_wrap(~ verification) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(text = element_text(size=18),
        axis.text.x = element_text(angle = 45, hjust = 1)) + 
  xlab("")
dev.off()
png(paste0("/blackhole/alessia/GLMM_article/robustness/Power_precision_gold", Dataset[2],"_adj.png"), res = 150, units = "cm", width = 18, height = 18)
p <- ggplot(d, aes(x=evaluation,y=sqrt(precision),color=evaluation))
p + scale_color_manual(values = cols) + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + facet_wrap(~ verification) +
    geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(text = element_text(size=18),
        axis.text.x = element_text(angle = 45, hjust = 1)) + 
  xlab("")
dev.off()
@ 

<<sensitivityGrid, dev="pdf", fig.width=8, fig.height=6, fig.cap="Sensitivity, where each algorithm's calls (adjusted $p$-value $< .1$) in the evaluation set (color boxes) is compared against itselfs (adjusted $p$-value $< .1$) in the verification set (grey labels).">>=
# d.glmm <- d.glmm[complete.cases(d.glmm),]
png(paste0("/blackhole/alessia/GLMM_article/robustness/Power_sensitivity_", Dataset[2],"_adj.png"), res = 200, units = "cm", width = 20, height = 16)
p <- ggplot(d, aes(x=evaluation,y=sensitivity,color=evaluation))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  scale_color_manual(values=cols) +
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title=element_text(size=15,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  ggtitle(paste0(Dataset, " - Dataset")) +
  xlab("")
dev.off()
@

<<precisionGrid, dev="pdf", fig.width=8, fig.height=6, fig.cap="Precision, where each algorithm's calls (adjusted $p$-value $< .1$) in the evaluation set (color boxes) is compared against itselfs (adjusted $p$-value $< .1$) in the verification set (grey labels).">>=
png(paste0("/blackhole/alessia/GLMM_article/robustness/Power_precision_",Dataset,"_adj.png"), res = 200, units = "cm", width = 20, height = 16)
p <- ggplot(d, aes(x=evaluation,y=precision,color=evaluation))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  scale_color_manual(values = cols) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 12),
        axis.text.y = element_text(size = 12),
        axis.title=element_text(size=14,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  ggtitle(paste0(Dataset, " - Dataset")) +
  xlab("")
dev.off()
@

\section{Compare sensitivity at a given precision}

In this section, we examine the false discovery rate (1 - precision)
for a given range of $\alpha$, the adjusted $p$-value cutoff for
calling a circRNA significant in the evaluation set. We then plot this
curve for all algorithms performance in the evalulation set, and using
each algorithm for determining the ``true'' calls in the verification set.
We also use these curves to make a plot of sensitivities for each
algorithm, using that $\alpha$ adjusted $p$-value threshold such that
the precision is 0.9 (hence and the false discovery rate is the desired 0.1).

<<fdrAtAlphaCalc, cache=TRUE>>=
nreps <- length(resTes.adj)
alphas <- exp(seq(from=log(.001), to=log(.2), length=100))
alphaOut <- .1
fdrAtAlpha <- do.call(rbind, lapply(namesAlgos, function(algo) {
  sigTestList <- lapply(1:nreps, function(i) lapply(alphas, function(alpha) which(resTes.adj[[i]][[algo]] < alpha)))
  callsTest <- sapply(1:nreps, function(i) {
    sapply(seq_along(alphas), function(j) {
      length(sigTestList[[i]][[j]])
    })
  }) 
  do.call(rbind, lapply(namesAlgos, function(algoOut) {
    fdr <- sapply(1:nreps, function(i) {
      sigHeldout <- resHeldout.adj[[i]][[algoOut]] < alphaOut  
      sapply(seq_along(alphas), function(j) {
        ifelse(sum(sigTestList[[i]][[j]]) > 0, mean(!sigHeldout[sigTestList[[i]][[j]]]), 0)
      })
    })
    data.frame(alpha=alphas, FDR=apply(fdr, 1, median), callsTest=apply(callsTest, 1, median), algorithm=rep(algo, 100), verification=rep(algoOut, 100))
  }))
}))

@ 


<<renameFDRResults>>=
fdrAtAlphaPlot <- fdrAtAlpha
fdrAtAlphaPlot$algorithm  = factor(fdrAtAlphaPlot$algorithm )
fdrAtAlphaPlot$verification = factor(fdrAtAlphaPlot$verification)
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "edgeR.robust", "edgeR-robust")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "edgeR.robust", "edgeR-robust")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "edgeR.ZINBWave", "edgeR-ZINB Wave")
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "edgeR.ZINBWave", "edgeR-ZINB Wave")
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "DESeq2.ZI", "DESeq2-ZeroInflated")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "DESeq2.ZI", "DESeq2-ZeroInflated")
fdrAtAlphaPlot$algorithm <- renameAtoB(fdrAtAlphaPlot$algorithm, "GLMM_NB", "GLMM")
fdrAtAlphaPlot$verification <- renameAtoB(fdrAtAlphaPlot$verification, "GLMM_NB", "GLMM")

@ 

<<fdrAtAlpha, fig.align="center", fig.cap="Actual versus nominal false discovery rate for the Bottomly et al. dataset. The actual false discovery rate was calculated using the median of (1 - precision) as in the previous precision plots, though here varying the adjusted p-value cutoff, i.e., the nominal FDR, for the evaluation set. A false positive was defined as a call in the evaluation set for a given critical value of adjusted p-value which did not have adjusted p-value less than 0.1 in the verification set.  Ideally, curves should fall on the identity line (indicated by a black line); curves that fall above indicate that an algorithm is too permissive (anti-conservative), curves falling below indicate that an algorithm does not use its type-I error budget, i.e., is conservative. DESeq2 had a false discovery rate nearly matching the nominal false discovery rate (black diagonal line) for the majority of algorithms used to determine the verification set calls. The old DESeq tool was often too conservative.">>=
# only show results when the evaluation algorithm has positive median calls
p <- ggplot(fdrAtAlphaPlot[fdrAtAlphaPlot$callsTest > 0,], aes(x=alpha, y=FDR, color=algorithm))
p + scale_color_manual(values = cols) + geom_line() + theme_bw() + geom_abline(intercept=0,slope=1) +
  facet_wrap(~ verification) + ylab("FDR (1 - precision)") + 
  xlab("evaluation set adjusted p-value cutoff") + 
  scale_x_continuous(breaks=c(0,.05,.1,.15)) 
  #scale_y_continuous(breaks=c(0,.05,.1,.15,.2,.25)) + 
  # coord_cartesian(ylim=c(-.01,.3), xlim=c(-.01,.2))

@

<<sensAtTargetCalc, cache=TRUE>>=
alphaTarget <- .1
alphaOut <- .1
sensAtTarget <- do.call(rbind, lapply(namesAlgos, function(algoOut) {
  do.call(rbind, lapply(namesAlgos, function(algo) {
    sens <- sapply(1:nreps, function(i) {
      sigHeldout <- resHeldout.adj[[i]][[algoOut]] < alphaOut
      idx <- fdrAtAlpha$algorithm == algo & fdrAtAlpha$verification == algoOut
      lessTarget <- which(fdrAtAlpha$FDR[idx] < alphaTarget)
      if ( length(lessTarget) == 0 ) return(0)
      alpha <- alphas[ lessTarget[length(lessTarget)] ]
      sigTest <- resTes.adj[[i]][[algo]] < alpha
      ifelse(sum(sigHeldout) > 0, mean(sigTest[sigHeldout]), 0) 
    })  
    data.frame(sensitivity=sens, algorithm=rep(algo, nreps), verification=rep(algoOut, nreps))
  }))
}))

@

<<renameSensAtTargetResults>>=
sensAtTarget$algorithm = factor(sensAtTarget$algorithm)
sensAtTarget$verification = factor(sensAtTarget$verification)
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "edgeR.robust", "edgeR-robust")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "edgeR.robust", "edgeR-robust")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "edgeR.ZINBWave", "edgeR-ZINB Wave")
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "edgeR.ZINBWave", "edgeR-ZINB Wave")
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "DESeq2.ZI", "DESeq2-ZeroInflated")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "DESeq2.ZI", "DESeq2-ZeroInflated")
sensAtTarget$algorithm <- renameAtoB(sensAtTarget$algorithm, "GLMM_NB", "GLMM")
sensAtTarget$verification <- renameAtoB(sensAtTarget$verification, "GLMM_NB", "GLMM")

@ 

<<sensAtTarget, fig.width=8, fig.height=6, fig.align="center",fig.cap="Sensitivity of algorithms evaluated while controlling the median precision. While it was generally noted that sensitivity and precision were negatively correlated, here this effect was controlled by setting the adjusted p-value cutoff for the evaluation set calls such that the median precision of all algorithms would be 0.9 (actual false discovery rate of 0.1). This amounted to finding the point on the x-axis in the previous figure, where the curve crosses 0.1 on the y-axis. For most algorithms, this meant setting an adjusted p-value cutoff below 0.1. DESeq2 often had the highest median sensitivity for a given target precision, though the variability across random replicates was generally larger than the difference between algorithms.">>=

p <- ggplot(sensAtTarget, aes(x=algorithm, y=sensitivity, color=algorithm))
p + scale_color_manual(values = cols) + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + facet_wrap(~ verification) +
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab("")

@ 

\clearpage

\section{Area Under Precision Recall Curve (AUPRC)}

<<Recallcurve, echo = FALSE , warning = FALSE, message = FALSE, error = FALSE>>=
library(PRROC)
getPrecisionAlgoGold <- function(alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigTest <- resTes.adj[[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout.adj[[i]][[gold]] < alphaOut)[sigTest])
  })))
}
precall = function(algo, rep, gold) {
  # rep = 1
  # recall = pr.curve(resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] < alphaOut],
  #                   resTes[[rep]][[algo]][!resHeldout[[rep]][[gold]] < alphaOut], curve = TRUE)$curve[, 1]
  # precision = pr.curve(resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] < alphaOut],
  #                      resTes[[rep]][[algo]][!resHeldout[[rep]][[gold]] < alphaOut], curve = TRUE)$curve[, 2]
  auc = pROC::roc(as.numeric(resHeldout.adj[[rep]][[gold]] <= alphaOut),
                    as.numeric(resTes.adj[[rep]][[algo]] <= alphaOut))
  # auc = AUC::roc(1-resTes[[rep]][[algo]],
  #                as.numeric(resHeldout[[rep]][[gold]] < alphaOut))
  fg <- 1-resTes.adj[[rep]][[algo]][resHeldout.adj[[rep]][[gold]] <= alphaOut]
  bg <- 1-resTes.adj[[rep]][[algo]][resHeldout.adj[[rep]][[gold]] > alphaOut]
  pr <- try(pr.curve(scores.class0 = fg, scores.class1 = bg, curve = T))
  # plot(pr)
  aupr = data_frame(#recall = pr$curve[,1],
                    #precision = pr$curve[,2],
                    AUC = auc$auc,
                    AUPRC = ifelse(class(pr)[1] == "try-error", NA, pr$auc.integral),
                    B = rep,
                    model = algo)
  return(aupr)
  }
res_algo = list()
res_accuracy = list()

for(gold in names(resTes[[1]][,-1])){
  for(algo in names(resTes[[1]][,-1])){
    res = rbindlist(lapply(1:nreps, function(x) precall(algo = algo, rep = x, gold = gold)))
    res_accuracy[[algo]] = res
  }
  res_algo = res_accuracy
}

AUPRC = rbindlist(res_accuracy, use.names = T)
AUPRC$model = factor(AUPRC$model)
AUPRC$model <- renameAtoB(AUPRC$model, "edgeR.robust", "edgeR-robust")
AUPRC$model <- renameAtoB(AUPRC$model, "edgeR.ZINBWave", "edgeR-ZINB Wave")
AUPRC$model<- renameAtoB(AUPRC$model, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
AUPRC$model <- renameAtoB(AUPRC$model, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
AUPRC$model<- renameAtoB(AUPRC$model, "DESeq2.ZI", "DESeq2-ZeroInflated")
AUPRC$model = renameAtoB(AUPRC$model, "GLMM_NB", "GLMM")
p <- ggplot(AUPRC, aes(x = reorder(model, AUPRC), y = AUPRC, color = model))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  scale_color_manual(values = cols) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15),
        axis.text.y = element_text(size = 15),
        axis.title=element_text(size=14,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  xlab("") +
  ggtitle(paste0(Dataset, " - Dataset"))


@

\section{Clustering of calls}

<<clustSetup>>=
alpha <- .1
library("abind")
library("ggplot2")
library("ggdendro")
library("cowplot")
library("gridExtra")
library("grid")
methods <- c("DESeq2",
             
             "edgeR.robust",
             
             "GLMM")
cols2 = cols
names(cols2) <- methods

# first with evaluation sets
nreps = 30
j0 <- lapply(1:nreps, function(i) {
  # i=1
  #print(i)
  dt <- resTes.adj[[i]][,-1]

  m <- as.matrix(dist(t(dt) <= alpha), method="binary")
  return(m)
})

j <- abind(j0,along=3)
average.Jaccard <- apply(j,c(1,2),mean)
average.Jaccard <- as.dist(average.Jaccard)
hcTest <- hclust(average.Jaccard)


# again with verification sets
j0 <- lapply(1:nreps, function(i) {
  dt <- resHeldout.adj[[i]][,-1]
  m <- as.matrix(dist(t(dt) <= alpha), method="binary")
  return(m)
})
j <- abind(j0,along=3)
average.Jaccard <- apply(j,c(1,2),mean)
average.Jaccard <- as.dist(average.Jaccard)
hcHeldout <- hclust(average.Jaccard)

@

<<clustMethods, dev="pdf", fig.align="center", fig.width=10, fig.height=12, fig.cap="Clustering of calls (adjusted $p$-value $< .1$) with distances based on the Jaccard index">>=

g_horizontal_dendrogram_Heldout <- ggplot() + 
    geom_segment(data=dendro_data(hcHeldout)$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_label(data=dendro_data(hcHeldout)$labels, aes(x=x, y=y, label=label, 
                                                         hjust=-0.05,color=label), nudge_y = 0) +
    coord_flip() + scale_y_reverse(expand = c(0,0,0,0)) + scale_x_reverse() +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "none",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) + 
  expand_limits(y = -round(max(segment(dendro_data(hcHeldout))$y) * 0.5, 1))


get_legend_dendo <- get_legend(ggplot() + 
    geom_segment(data=dendro_data(hcHeldout)$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_point(data=dendro_data(hcHeldout)$labels, aes(x=x, y=y,color=factor(label, levels = names(cols), ordered = T)),size = 5) +
    scale_y_continuous() +
    #scale_y_reverse(expand=c(2,1)) + scale_x_reverse(expand=c(2,1)) +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "bottom",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) +
      guides(color = guide_legend(title = "Methods:",title.position = "left",nrow = 2)))

# now add the title
title <- ggdraw() +
  draw_label(
    paste0("Clustering of calls in Verification set (", Dataset, " - Dataset)"),
    fontface = 'bold',
    x = 0,
    hjust = 0, size = 12
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

g_horizontal_dendrogram_Test <- ggplot() + 
    geom_segment(data=dendro_data(hcTest)$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_label(data=dendro_data(hcTest)$labels, aes(x=x, y=y, label=label, hjust=-0.05,color=label), nudge_y = 0) +
    coord_flip() + scale_y_reverse(expand = c(0,0,0,0)) + scale_x_reverse() +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "none",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) + 
  expand_limits(y = -round(max(segment(dendro_data(hcTest))$y) * 0.5, 1))


# now add the title
titleTest <- ggdraw() +
  draw_label(
    paste0("Clustering of calls in Evaluation set (", Dataset, " - Dataset)"),
    fontface = 'bold',
    x = 0,
    hjust = 0, size = 12
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

Heldplot <- plot_grid(title, g_horizontal_dendrogram_Heldout,
                    # plot_grid(plotlist = g_horizontal_dendrogram_Heldout, 
                    #          ncol = 2, #align = 'vh',
                    #          hjust = c(-0.1, 0.8, -0.1, 0.8, -0.1, 0.8, -0.1), 
                    #          vjust = -1.35,
                    #          labels = names(heldMat), 
                    #          label_size = 9), 
                    ncol = 1, rel_heights = c(0.1, 1))
Testplot <- plot_grid(titleTest, g_horizontal_dendrogram_Test,
                    # plot_grid(plotlist = g_horizontal_dendrogram_Test, 
                    #          ncol = 2, #align = 'vh',
                    #          hjust = c(-0.1, 0.8, -0.1, 0.8, -0.1, 0.8, -0.1), 
                    #          vjust = -1.35,
                    #          labels = names(testMat),
                    #          label_size = 9
                    #          ), 
                    ncol = 1, rel_heights = c(0.1, 1))
# png("/blackhole/alessia/CircModel/robustness/ALZ_Clusteringofcalls.png", res = 200, units = "cm", width = 30, height = 45)
grid.arrange(Heldplot, Testplot, get_legend_dendo, ncol=2, nrow=2, widths=c(2.3, 2.3), heights=c(1, 0.1))
# dev.off()
@

\clearpage

\section{Session information}

<<sessInfo, echo=FALSE, results="asis">>=
toLatex(sessionInfo())
@ 


\end{document}
